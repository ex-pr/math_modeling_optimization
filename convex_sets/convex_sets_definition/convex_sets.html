<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daria Dubovskaia">

<title>Homework 3: Convex Sets</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="convex_sets_files/libs/clipboard/clipboard.min.js"></script>
<script src="convex_sets_files/libs/quarto-html/quarto.js"></script>
<script src="convex_sets_files/libs/quarto-html/popper.min.js"></script>
<script src="convex_sets_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="convex_sets_files/libs/quarto-html/anchor.min.js"></script>
<link href="convex_sets_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="convex_sets_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="convex_sets_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="convex_sets_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="convex_sets_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Homework 3: Convex Sets</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Daria Dubovskaia </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="problem-1-cvx-book-2.12" class="level2">
<h2 class="anchored" data-anchor-id="problem-1-cvx-book-2.12">Problem 1 (cvx-book 2.12):</h2>
<p>Which of the following sets are convex? For each case give the reason(s) why or why not</p>
<ol type="a">
<li><p>A slab, i.e., a set of the form <span class="math inline">\(\{x \in \mathbb{R}^n\, |\, \alpha \leq \mathbf{a}^T \mathbf{x} \leq{\beta}\}\)</span>.</p></li>
<li><p>A rectangle, i.e., a set of the form <span class="math inline">\(\{x \in \mathbb{R}^n\, |\, \alpha_i \leq x_i \leq \beta_i, i = 1,\cdots,\, n\}\)</span>. A rectangle is sometimes called a hyperrectangle when n &gt; 2.</p></li>
<li><p>A wedge, i.e., <span class="math inline">\(\{ \mathbf{x} \in \mathbb{R}^n\, |\, \mathbf{a_1}^T\mathbf{x} \leq b_1, \mathbf{a}_2^T\mathbf{x}\leq b_2\}\)</span></p></li>
<li><p>The set of points closer to a given point than a given set, i.e., <span class="math inline">\(\{ \mathbf{x}\, |\, \|\mathbf{x} − \mathbf{x}_0\|^2 \leq \|\mathbf{x} − \mathbf{y}\|^2\)</span> for all <span class="math inline">\(y \in S\}\)</span> where <span class="math inline">\(S  \subseteq \mathbb{R}^n\)</span>.</p></li>
<li><p>The set of points closer to one set than another, i.e., <span class="math inline">\(\{\mathbf{x}\, | \text{dist}(\mathbf{x}, S) \leq \text{dist}(\mathbf{x}, T )\}\)</span>, where <span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span> <span class="math inline">\(\subseteq \mathbf{R}^N\)</span>, and <span class="math inline">\(\text{dist}(x, S) = \inf\{\|\mathbf{x}  − \mathbf{z}\|^2 | \mathbf{z} \in S\}\)</span>.</p></li>
</ol>
<p><strong>Solution:</strong></p>
<p><strong>a.</strong> This set is called slab, it consists of all points <span class="math inline">\(\mathbf{x}\)</span> whose dot product with a vector <span class="math inline">\(\mathbf{a}\)</span> lies between <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> (<span class="math inline">\(\alpha \leq \beta\)</span>). Geometrically, it describes the region between two parallel hyperplanes defined by <span class="math inline">\(\mathbf{a}^T \mathbf{x} = \alpha\)</span> and <span class="math inline">\(\mathbf{a}^T \mathbf{x} = \beta\)</span>.</p>
<p>We can express this set as the intersection of two half-spaces:</p>
<p><span class="math display">\[\{x \in \mathbb{R}^n\, |\, \mathbf{a}^T \mathbf{x} \leq{\beta}\},\]</span> <span class="math display">\[\{x \in \mathbb{R}^n\, |\, \mathbf{a}^T \mathbf{x}  \geq \alpha \}.\]</span></p>
<p>Each half-space is convex because if you take any two points in a half-space, any convex combination of those points will also lie in the half-space. Convexity is preserved under intersection. Since the intersection of convex sets is itself convex, it follows that the slab is a <strong>convex</strong> set (Boyd &amp; Vandenberghe, 2004, p.36).</p>
<p><strong>b.</strong> A rectangle (or a hyperrectangle when n &gt; 2) is defined by bounds on each coordinate <span class="math inline">\(\{x \in \mathbb{R}^n\, |\, \alpha_i \leq x_i \leq \beta_i, i = 1,\cdots,\, n\}\)</span>. We can express this set as the intersection of <span class="math inline">\(2n\)</span> half-spaces:</p>
<p><span class="math display">\[\{x \in \mathbb{R}^n\, |\, x_i \leq \beta_i\},\]</span> <span class="math display">\[\{x \in \mathbb{R}^n\, |\, x_i \geq \alpha_i\},\]</span></p>
<p>for each <span class="math inline">\(i = 1,\cdots,\, n\)</span>.</p>
<p>Each half-space is convex, and since the intersection of convex sets is convex, the rectangle is a convex set (similar to the solution in part (a)). Also, as a polyhedron, it is the intersection of halfspaces and hyperplanes (which are convex), and therefore is convex (Boyd &amp; Vandenberghe, 2004, p.36). Therefore, a rectangle is a <strong>convex</strong> set.</p>
<p><strong>c.</strong> This set is the intersection of two half-spaces:</p>
<p><span class="math display">\[\{ \mathbf{x} \in \mathbb{R}^n\, |\, \mathbf{a_1}^T\mathbf{x} \leq b_1\}, \\\]</span></p>
<p><span class="math display">\[ \{ \mathbf{x} \in \mathbb{R}^n\, |\, \mathbf{a}_2^T\mathbf{x}\leq b_2\},\]</span></p>
<p>where <span class="math inline">\(\mathbf{a_1}, \mathbf{a_2} \in \mathbb{R}^n\)</span> and <span class="math inline">\(b_1, b_2 \in \mathbb{R}\)</span>.</p>
<p>Each half-space is convex, and since the intersection of convex sets is convex, the wedge is a convex set (similar to the solution in part (a)). Also, as a polyhedron, it is the intersection of two halfspaces (which are convex), and therefore is convex (Boyd &amp; Vandenberghe, 2004, p.36). Therefore, a wedge is a <strong>convex</strong> set.</p>
<p><strong>d.</strong> As shown in the example for Euclidean balls (Boyd &amp; Vandenberghe, 2004, p.29), we can rewrite the squared norm as: <span class="math inline">\(\{ \mathbf{x}\, |\, \|\mathbf{x} − \mathbf{x}_0\|^2 \leq \|\mathbf{x} − \mathbf{y}\|^2\)</span> for all <span class="math inline">\(y \in S\}\)</span> where <span class="math inline">\(S  \subseteq \mathbb{R}^n\)</span>,</p>
<p><span class="math display">\[\|\mathbf{x} − \mathbf{x}_0\|^2 = (\mathbf{x} - \mathbf{x}_0)^T (\mathbf{x} - \mathbf{x}_0) = \mathbf{x}^T\mathbf{x}-2\mathbf{x}^T\mathbf{x}_0+\mathbf{x}_0^T\mathbf{x}_0,\]</span></p>
<p><span class="math display">\[\|\mathbf{x} − \mathbf{y}\|^2 = (\mathbf{x} - \mathbf{y})^T (\mathbf{x} - \mathbf{y})=\mathbf{x}^T\mathbf{x}-2\mathbf{x}^T\mathbf{y}+\mathbf{y}^T\mathbf{y}.\]</span></p>
<p>The inequality becomes:</p>
<p><span class="math display">\[\|\mathbf{x} − \mathbf{x}_0\|^2 \leq \|\mathbf{x} − \mathbf{y}\|^2,\]</span></p>
<p><span class="math display">\[\mathbf{x}^T\mathbf{x}-2\mathbf{x}^T\mathbf{x}_0+\mathbf{x}_0^T\mathbf{x}_0 \leq \mathbf{x}^T\mathbf{x}-2\mathbf{x}^T\mathbf{y}+\mathbf{y}^T\mathbf{y},\]</span> <span class="math display">\[2\mathbf{x}^T(\mathbf{y} - \mathbf{x}_0) \leq \mathbf{y}^T\mathbf{y} - \mathbf{x}_0^T\mathbf{x}_0,\]</span> <span class="math display">\[\mathbf{x}^T \mathbf{d} \leq \frac{\textbf{||y||}^2 - \textbf{||x0||}^2}{2},\]</span></p>
<p>for a fixed <span class="math inline">\(y\in S\)</span>, where <span class="math inline">\(\mathbf{d}=\mathbf{y} - \mathbf{x}_0.\)</span></p>
<p>This is a linear inequality in <span class="math inline">\(\mathbf{x}\)</span>, it defines a halfspace. The set of points <span class="math inline">\(\mathbf{x}\)</span> that satisfy the condition for all <span class="math inline">\(y \in S\)</span> is the intersection of infinitely many halfspaces (one for each <span class="math inline">\(y \in S\)</span>).</p>
<p>Convexity is preserved under intersection. Since the intersection of convex sets is itself convex, it follows that the described set is <strong>convex</strong> (Boyd &amp; Vandenberghe, 2004, p.36).</p>
<p><strong>e.</strong> We can rewrite the condition as:</p>
<p><span class="math display">\[\text{dist}(\mathbf{x}, S) - \text{dist}(\mathbf{x}, T ) \leq 0,\]</span></p>
<p><span class="math display">\[\text{inf}_{\mathbf{z} \in S}||\mathbf{x}-\mathbf{z}||^2 - \text{inf}_{\mathbf{w} \in T}||\mathbf{x}-\mathbf{w}||^2 \leq 0,\]</span></p>
<p>for every <span class="math inline">\(\mathbf{x}\)</span>, there is <span class="math inline">\(\mathbf{z} \in S\)</span> such that <span class="math inline">\(||\mathbf{x}-\mathbf{z}||^2 \leq ||\mathbf{x}-\mathbf{w}||^2\)</span> for all <span class="math inline">\(\mathbf{w} \in T\)</span>.</p>
<p>The distance function <span class="math inline">\(\text{dist}(\mathbf{x}, S)\)</span> is convex if <span class="math inline">\(S\)</span> is a convex set (Boyd &amp; Vandenberghe, 2004, p.36). Similarly, <span class="math inline">\(\text{dist}(\mathbf{x}, T)\)</span> is convex if <span class="math inline">\(T\)</span> is convex.</p>
<p>But this is the difference of two convex functions. Therefore, the set defined by this inequality is not necessarily convex. For example <strong>convex case</strong>, if we consider <span class="math inline">\(S=\{(0,0)\}, T=\{(2,0)\}\)</span> in <span class="math inline">\(\mathbb{R}^2\)</span>, the condition becomes: <span class="math display">\[||\mathbb{x} - (0,0)|| \leq ||\mathbb{x}-(2,0)||,\]</span></p>
<p><span class="math display">\[x_1^2 + x_2^2 \leq (x_1-2)^2+x_2^2,\]</span></p>
<p><span class="math display">\[x_1 \leq 1,\]</span></p>
<p>which defines a halfspace, which is convex.</p>
<p>But if <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> are more complex or non-convex, the set can become non-convex. For example, if <span class="math inline">\(S\)</span> is the line segment from (0,0) to (0,2) and <span class="math inline">\(T\)</span> is the line segment from (2,0) to (2,2), the set of points closer to <span class="math inline">\(S\)</span> than to <span class="math inline">\(T\)</span> can be non-convex.</p>
<p>As a result, without additional assumptions about <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span>, the set is not guaranteed to be convex.</p>
</section>
<section id="problem-2-cvx-book-2.15" class="level2">
<h2 class="anchored" data-anchor-id="problem-2-cvx-book-2.15">Problem 2 (cvx-book 2.15):</h2>
<p>Some sets of probability distributions. Let <span class="math inline">\(x\)</span> be a real-valued random variable with probability distribution <span class="math inline">\(\mathbf{prob}(x = a_i) = p_i, i = 1 , . . . , n\)</span>, where <span class="math inline">\(a_1 &lt; a_2 &lt;· · · &lt; a_n\)</span>. Of course <span class="math inline">\(p \in \mathbb{R}^n\)</span> lies in the standard probability simplex <span class="math inline">\(P = \{\mathbf{p} | \mathbf{1}^T \mathbf{p} = 1, \mathbf{p} \succeq 0\}\)</span>. Which of the following conditions are convex in <span class="math inline">\(\mathbf{p}\)</span>? (That is, for which of the following conditions is the set of <span class="math inline">\(\mathbf{p} \in P\)</span> that satisfy the condition convex?) For each case give the reason(s) why or why not.</p>
<ol type="a">
<li><p>The set of all <span class="math inline">\(\mathbf{p}\)</span> where the expectation of the function <span class="math inline">\(f(x)\)</span> is between two limits: <span class="math inline">\(\alpha \leq Ef(x) \leq \beta\)</span>, <span class="math inline">\(Ef(x) = \sum_{i=1}^n p_i f(a_i)\)</span>. Here <span class="math inline">\(f(x)\)</span> is a function from <span class="math inline">\(\mathbb{R}\)</span> to <span class="math inline">\(\mathbb{R}\)</span>.</p></li>
<li><p>The set of all <span class="math inline">\(\mathbf{p}\)</span> such that the probability that <span class="math inline">\(\mathbf{prob}(x &gt; \alpha) \leq \beta\)</span></p></li>
<li><p>The set of all <span class="math inline">\(\mathbf{p}\)</span> such that the expectation of <span class="math inline">\(|x|^3\)</span> is greater than a given constant <span class="math inline">\(\alpha\)</span> times the expectation of <span class="math inline">\(|x|\)</span>: <span class="math inline">\(E|x^3| \leq \alpha E|x|\)</span></p></li>
<li><p>The set of all <span class="math inline">\(\mathbf{p}\)</span> such that the expectation of <span class="math inline">\(x^2\)</span> is less than a given constant <span class="math inline">\(\alpha\)</span>: <span class="math inline">\(Ex^2 \leq \alpha\)</span></p></li>
</ol>
<p><strong>Solution:</strong></p>
<p><strong>a.</strong> <span class="math inline">\(a_i\)</span> are fixed values and <span class="math inline">\(f\)</span> is a given function, each <span class="math inline">\(f(a_i)\)</span> is a constant. As a result, we can rewrite and get a linear function of <span class="math inline">\(\mathbf{p}\)</span>: <span class="math display">\[Ef(x) = p_1 f(a_1) + p_2 f(a_2) + ... + p_n f(a_n) = \mathbf{f}^T \mathbf{p},\]</span> the condition becomes: <span class="math display">\[\alpha \leq \mathbf{f}^T \mathbf{p} \leq \beta,\]</span> the set we are examining: <span class="math display">\[\{\mathbf{p} \in P \, |\, \alpha \leq \mathbf{f}^T \mathbf{p} \leq \beta \},\]</span> where <span class="math inline">\(P = \{\mathbf{p} | \mathbf{1}^T \mathbf{p} = 1, \mathbf{p} \succeq 0\}\)</span> is the probability simplex.</p>
<p>First, let’s check if <span class="math inline">\(P\)</span> is convex:</p>
<ul>
<li><p><span class="math inline">\(\mathbf{1}^T \mathbf{p} = 1\)</span> is a linear equality,</p></li>
<li><p><span class="math inline">\(p_i \geq 0\)</span> for <span class="math inline">\(i = 1, ..., n\)</span> is a linear inequality.</p></li>
</ul>
<p>Section 2.2.4 on “Polyhedra” (Boyd &amp; Vandenberghe, 2004, p.31) states that a polyhedron is defined as the solution set of a finite number of linear equalities and inequalities, is convex. The probability simplex fits this description exactly (Example 2.5, Boyd &amp; Vandenberghe, 2004, p.33), so <span class="math inline">\(P\)</span> is convex.</p>
<p>Next, we analyze the constraints <span class="math inline">\(\alpha \leq \mathbf{f}^T \mathbf{p} \leq \beta:\)</span></p>
<ul>
<li><span class="math inline">\(\mathbf{f}^T \mathbf{p} \geq \alpha\)</span> is a linear inequality in <span class="math inline">\(\mathbf{p}\)</span>, it defines a half-space,</li>
<li><span class="math inline">\(\mathbf{f}^T \mathbf{p} \leq \beta\)</span> is another linear inequality in <span class="math inline">\(\mathbf{p}\)</span>, it defines another half-space.</li>
</ul>
<p>Our set is the the intersection of:</p>
<ul>
<li><p>The convex set <span class="math inline">\(P\)</span>,</p></li>
<li><p>The half-space <span class="math inline">\(\{\mathbf{p} | \mathbf{f}^T \mathbf{p} \geq \alpha\}\)</span>,</p></li>
<li><p>The half-space <span class="math inline">\(\{\mathbf{p} | \mathbf{f}^T \mathbf{p} \leq \beta\}\)</span>.</p></li>
</ul>
<p>Convexity is preserved under intersection. Since the intersection of convex sets is itself convex. This extends to any finite number of convex sets. Since <span class="math inline">\(P\)</span> and the two half-spaces are convex, it follows that their intersection is <strong>convex</strong> (Boyd &amp; Vandenberghe, 2004, p.36).</p>
<p><strong>b.</strong> Let’s express the probability as the sum of probabilities where <span class="math inline">\(x &gt; \alpha\)</span> (we get a linear function of p): <span class="math display">\[\mathbf{prob}(x &gt; \alpha) = \sum_{a_i &gt; \alpha} p_i,\]</span></p>
<p>where <span class="math inline">\(i = k\)</span> , . . . , <span class="math inline">\(n\)</span>, <span class="math inline">\(k\)</span> is a smallest index such that <span class="math inline">\(a_k &gt; \alpha\)</span>.</p>
<p>Thus, we get a linear inequality in <span class="math inline">\(\mathbf{p}\)</span> which defines a halfspace:</p>
<p><span class="math display">\[\{\mathbf{p} \in P \, |\, \sum_{a_i &gt; \alpha} p_i \leq \beta \}\]</span>.</p>
<p>As a result, the probability simplex <span class="math inline">\(P\)</span> is convex, the halfspace is convex (Boyd &amp; Vandenberghe, 2004, p.27), their intersection results in a <strong>convex</strong> set (Boyd &amp; Vandenberghe, 2004, p.36).</p>
<p><strong>c.</strong> We can rewrite the inequality as (Yang, 2019, p.30):</p>
<p><span class="math display">\[E|x^3| \leq \alpha E|x|,\]</span> <span class="math display">\[\sum_{i=1}^n p_i |a_i|^3 \leq \alpha \sum_{i=1}^n p_i |a_i|.\]</span></p>
<p>Both sides are linear functions of <span class="math inline">\(\mathbf{p}\)</span>, we can rewrite the above inequality as a linear inequality in <span class="math inline">\(\mathbf{p}\)</span>:</p>
<p><span class="math display">\[\sum_{i=1}^n p_i (|a_i|^3 - \alpha |a_i|) \leq 0,\]</span> where <span class="math inline">\(v_i = |a_i|^3 - \alpha |a_i|\)</span> are constants. The final linear inequality to consider:</p>
<p><span class="math display">\[\{\mathbf{p} \in P \, |\,\mathbf{v}^T \mathbf{p} \leq 0 \}.\]</span></p>
<p>As in the previous problems, the probability simplex <span class="math inline">\(P\)</span> is convex, the halfspace is convex (Boyd &amp; Vandenberghe, 2004, p.27), their intersection results in a <strong>convex</strong> set (Boyd &amp; Vandenberghe, 2004, p.36).</p>
<p><strong>d.</strong> We can rewrite the inequality as (Yang, 2019, p.30): <span class="math display">\[Ex^2 \leq \alpha,\]</span></p>
<p><span class="math display">\[\sum_{i=1}^n p_i a_i^2 \leq \alpha, \]</span></p>
<p><span class="math display">\[\{\mathbf{p} \in P \, |\,\mathbf{a}^T \mathbf{p} \leq \alpha \},\]</span></p>
<p>As in the previous problems, the probability simplex <span class="math inline">\(P\)</span> is convex, the halfspace is convex (Boyd &amp; Vandenberghe, 2004, p.27), their intersection results in a <strong>convex</strong> set (Boyd &amp; Vandenberghe, 2004, p.36).</p>
</section>
<section id="problem-3-bounded-value-least-squares-for-wine-mixing" class="level2">
<h2 class="anchored" data-anchor-id="problem-3-bounded-value-least-squares-for-wine-mixing">Problem 3: Bounded Value Least Squares for Wine Mixing</h2>
<p>We have seen several examples so far in the couse where we would like to have inequality constraints on the decision variable for our least squares problem, for example to prevent non-sensical solutions like spending a negative amount of money on advertising, limiting the total investment in certain types of assets, or perhaps bounding the value of a statistical coefficient to a certain range. Non-negative least squares is a type of least squares problem where the decision variables <span class="math inline">\(\mathbf{x}\geq 0\)</span>, and Bounded-Value Least Squares allows for more general constraints.</p>
<p>This type of least-squares problem needs to be solved algorithmically, and we will use it to get our first practice using the <code>CVX</code> software package. You should install <code>CVXPY</code>, <code>CVXR</code>, or a flavor of <code>CVX</code> compatible with whatever software you are using to solve the problem and use <code>CVX</code> to solve this problem.</p>
<p>The problem is one of finding a mixture of wines which achieves certain chemical characteristics. I have attached a dataset which contains data on the chemical composition of 6 different wines (the dataset originates from kaggle but is reduced for our purposes). Each wine is described according to 11 chemical characteristics, including <code>alcohol</code>, <code>residual sugar</code>, <code>chlorides</code>, etc. I have also provided data for the chemical composition for a target wine.</p>
<ul>
<li><a href="https://github.com/georgehagstrom/DATA609Spring2025/blob/main/website/assignments/labs/labData/wine_data.csv">wine_data.csv</a></li>
<li><a href="https://github.com/georgehagstrom/DATA609Spring2025/blob/main/website/assignments/labs/labData/target.csv">target.csv</a></li>
</ul>
<p>The goal of this problem is to find the blend of wines which has chemical characteristics closest to the target wine.</p>
<p>Concretely, you are solving for weights <span class="math inline">\(\mathbf{p}\)</span>. The concentration of chemical <span class="math inline">\(i\)</span> in wine <span class="math inline">\(j\)</span> is given by the matrix <span class="math inline">\(C_{ij}\)</span>, and the concentration in the blended wine is: <span class="math display">\[
c_{blend,i} = \sum_{j=1}^6 C_{ij} p_j,
\]</span> so that the overall concentration vector in the blend satisfies: <span class="math display">\[
\mathbf{c}_{blend} = C\mathbf{p}
\]</span></p>
<p>The vector <span class="math inline">\(\mathbf{p}\)</span> is a discrete probability distribution, meaning that all entries are non-negative and must sum to <span class="math inline">\(1\)</span> (you can’t add negative wine). The range of each chemical varies greatly, so our objective function should incorporate a penalty that is weighted according to the magnitude of the value in the target function:</p>
<p><span class="math display">\[
\min_{\mathbf{p}} \sum_{i=1}^{11} \left(\frac{c_i-c_{blend,_i}}{c_i}\right)^2
\]</span></p>
<p>Implement this least squares optimization problem using CVX and determine the optimal blend of wines to match the target.</p>
<p><strong>Solution:</strong></p>
<p>We have the following information:</p>
<ul>
<li><p>Wine data: A matrix C (size 11x6), where <span class="math inline">\(C_{ij}\)</span> is the concentration of chemical <span class="math inline">\(i\)</span> in wine <span class="math inline">\(j\)</span>. The 11 chemicals are: fixed acidity, volatile acidity, citric acid, residual sugar, chlorides, free sulfur dioxide, total sulfur dioxide, density, pH, sulphates, and alcohol. Each of the 6 columns corresponds to a different wine.</p></li>
<li><p>Target data: A vector <span class="math inline">\(c\)</span> of length 11, representing the desired chemical composition of the blended wine.</p></li>
<li><p>A 6-dimensional probability vector <span class="math inline">\(\mathbf{p}\)</span> containing blend weights, where <span class="math inline">\(\mathbf{p}_j\)</span> is the proportion of wine <span class="math inline">\(j\)</span> in the final blend. The vector satisfies the following constraints (weights are non-negative, and they sum to 1): <span class="math display">\[\mathbf{p} \geq 0,  \sum_{j=1}^6 p_j = 1,\]</span> meaning that we cannot have negative proportions of wine, and the total blend proportions must sum to 1.</p></li>
<li><p>The overall concentration vector in the blend: <span class="math inline">\(\mathbf{c}_{blend} = C\mathbf{p}\)</span>, where a vector <span class="math inline">\(\mathbf{c}_{blend}\)</span> is a vector of length 11, and <span class="math inline">\(c_{blend,i} = \sum_{j=1}^6 C_{ij} p_j\)</span>.</p></li>
<li><p>The goal is to minimize the weighted sum of squared differences between the target wine and the blended wine: <span class="math display">\[
\min_{\mathbf{p}} \sum_{i=1}^{11} \left(\frac{c_i-c_{blend,i}}{c_i}\right)^2,
\]</span> where <span class="math inline">\(c_i\)</span> is the target concentration of chemical <span class="math inline">\(c_i\)</span>.</p></li>
</ul>
<p>First, we import the datasets containing the chemical compositions of six wines and the target wine from GitHub. We need to transform the data to the required numpy arrays for consistency with the equation <span class="math inline">\(\mathbf{c}_{blend} = C\mathbf{p}\)</span>. The wine data is stored in a DataFrame where rows represent wines and columns represent chemical properties (size 6x11). To match our mathematical formulation above, we transpose the DataFrame so that rows represent chemicals and columns represent wines, obtaining a <strong>11x6</strong> matrix <span class="math inline">\(C\)</span>. The target data is stored as a single-row DataFrame. We extract the values and flatten it into a 1D array <span class="math inline">\(c_{blend}\)</span> of size <strong>11</strong>.</p>
<p>We also define <span class="math inline">\(\mathbf{p}\)</span> as a 6-dimensional probability vector using cp.Variable(), ensuring it meets the non-negativity and sum-to-one constraints.</p>
<p>In Python, we directly implemented the formula from the minimization problem. We first compute the difference between the target and blended compositions (residual). Next, we normalize it by dividing each residual by the target value (element-wise). The optimization objective directly implements the sum of squared weighted residuals. We impose the constraints, and the optimization is solved using cp.Problem(). Due to floating-point precision, small negative weights are clipped to zero by np.maximum(optimal_p, 0).</p>
<p>The solver returns the optimal proportions of the six wines in the blend. We also add a verification that the constraints are satisfied (weights sum to 1 and are non-negative). The optimal blend comprises 61.4% Wine 1, 34.7% Wine 3, and 3.9% Wine 6, with Wines 2, 4, and 5 excluded (0%) and an objective value of 0.4097 (this isn’t zero, indicating the blend isn’t a perfect match). Wine 1 and 3 contribute 96.1% of the blend (61.4% from Wine 1 and 34.7% from Wine 3). These wines may have chemical compositions most similar to the target wine, making them optimal choices. Wines 2, 4, and 5 contribute nearly nothing (~0%). Their chemical properties might deviate significantly from the target (e.g., Wine 2’s volatile acidity of 0.745 vs.&nbsp;target 0.35). Wine 6 contributes a ~3.9%. This wine might help adjust specific chemical properties (such as pH or sulphates).</p>
<p>The plot below shows the absolute differences between the target and blended wine across the 11 chemical properties. A small absolute difference means a chemical characteristic was well-matched. A large difference suggests the available wines could not exactly replicate the target composition. The percentage difference plot shows how much the blended wine deviates from the target in relative terms. This helps identify chemicals that are overrepresented or underrepresented in the final blend.</p>
<p>Based on these plots, we can conclude that density, chlorides, and total sulfur dioxide are well-matched (near 0% difference), but fixed acidity (+35%) is higher due to Wines 1 and 3’s values (12.6, 7.8) exceeding the target (7.9). Residual sugar (-30%) and alcohol (-15%) are lower because the selected wines undershoot the target (e.g., 2.8, 1.9, 1.9 vs.&nbsp;3.6 for sugar). Some chemical properties cannot be perfectly replicated using the available six wines. The optimizer finds the best possible trade-off while maintaining non-negative proportions.</p>
<div id="52fa4908" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Import libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1ae2e304" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Load dataset from Github</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>data_1 <span class="op">=</span> pd.read_csv(<span class="st">'https://media.githubusercontent.com/media/georgehagstrom/DATA609Spring2025/refs/heads/main/website/assignments/labs/labData/wine_data.csv'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>data_2 <span class="op">=</span> pd.read_csv(<span class="st">'https://media.githubusercontent.com/media/georgehagstrom/DATA609Spring2025/refs/heads/main/website/assignments/labs/labData/target.csv'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>data_1.head(), data_1.describe(),data_1.info(), data_2.head(), data_2.describe(),data_2.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 11 columns):
 #   Column                Non-Null Count  Dtype  
---  ------                --------------  -----  
 0   fixed acidity         6 non-null      float64
 1   volatile acidity      6 non-null      float64
 2   citric acid           6 non-null      float64
 3   residual sugar        6 non-null      float64
 4   chlorides             6 non-null      float64
 5   free sulfur dioxide   6 non-null      int64  
 6   total sulfur dioxide  6 non-null      int64  
 7   density               6 non-null      float64
 8   pH                    6 non-null      float64
 9   sulphates             6 non-null      float64
 10  alcohol               6 non-null      float64
dtypes: float64(9), int64(2)
memory usage: 660.0 bytes
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1 entries, 0 to 0
Data columns (total 11 columns):
 #   Column                Non-Null Count  Dtype  
---  ------                --------------  -----  
 0   fixed acidity         1 non-null      float64
 1   volatile acidity      1 non-null      float64
 2   citric acid           1 non-null      float64
 3   residual sugar        1 non-null      float64
 4   chlorides             1 non-null      float64
 5   free sulfur dioxide   1 non-null      int64  
 6   total sulfur dioxide  1 non-null      int64  
 7   density               1 non-null      float64
 8   pH                    1 non-null      float64
 9   sulphates             1 non-null      float64
 10  alcohol               1 non-null      float64
dtypes: float64(9), int64(2)
memory usage: 220.0 bytes</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>(   fixed acidity  volatile acidity  citric acid  residual sugar  chlorides  \
 0           12.6             0.410         0.54             2.8      0.103   
 1            8.4             0.745         0.11             1.9      0.090   
 2            7.8             0.500         0.30             1.9      0.075   
 3            9.2             0.755         0.18             2.2      0.148   
 4            6.7             0.620         0.21             1.9      0.079   
 
    free sulfur dioxide  total sulfur dioxide  density    pH  sulphates  \
 0                   19                    41  0.99939  3.21       0.76   
 1                   16                    63  0.99650  3.19       0.82   
 2                    8                    22  0.99590  3.31       0.56   
 3                   10                   103  0.99690  2.87       1.36   
 4                    8                    62  0.99700  3.52       0.58   
 
    alcohol  
 0     11.3  
 1      9.6  
 2     10.4  
 3     10.2  
 4      9.3  ,
        fixed acidity  volatile acidity  citric acid  residual sugar  \
 count       6.000000          6.000000      6.00000        6.000000   
 mean        8.650000          0.608333      0.22500        2.166667   
 std         2.125794          0.135302      0.18251        0.355903   
 min         6.700000          0.410000      0.01000        1.900000   
 25%         7.350000          0.530000      0.12750        1.900000   
 50%         8.100000          0.620000      0.19500        2.050000   
 75%         9.000000          0.713750      0.27750        2.275000   
 max        12.600000          0.755000      0.54000        2.800000   
 
        chlorides  free sulfur dioxide  total sulfur dioxide   density  \
 count   6.000000             6.000000              6.000000  6.000000   
 mean    0.093333            11.500000             56.166667  0.996502   
 std     0.029790             4.806246             27.476657  0.001961   
 min     0.065000             8.000000             22.000000  0.993320   
 25%     0.076000             8.000000             42.250000  0.996050   
 50%     0.084500             9.000000             54.000000  0.996700   
 75%     0.099750            14.500000             62.750000  0.996975   
 max     0.148000            19.000000            103.000000  0.999390   
 
              pH  sulphates    alcohol  
 count  6.000000   6.000000   6.000000  
 mean   3.236667   0.765000  10.433333  
 std    0.214445   0.315706   0.964711  
 min    2.870000   0.510000   9.300000  
 25%    3.195000   0.565000   9.750000  
 50%    3.260000   0.670000  10.300000  
 75%    3.317500   0.805000  11.075000  
 max    3.520000   1.360000  11.800000  ,
 None,
    fixed acidity  volatile acidity  citric acid  residual sugar  chlorides  \
 0            7.9              0.35         0.46             3.6      0.078   
 
    free sulfur dioxide  total sulfur dioxide  density    pH  sulphates  \
 0                   15                    37   0.9973  3.35       0.86   
 
    alcohol  
 0     12.8  ,
        fixed acidity  volatile acidity  citric acid  residual sugar  \
 count            1.0              1.00         1.00             1.0   
 mean             7.9              0.35         0.46             3.6   
 std              NaN               NaN          NaN             NaN   
 min              7.9              0.35         0.46             3.6   
 25%              7.9              0.35         0.46             3.6   
 50%              7.9              0.35         0.46             3.6   
 75%              7.9              0.35         0.46             3.6   
 max              7.9              0.35         0.46             3.6   
 
        chlorides  free sulfur dioxide  total sulfur dioxide  density    pH  \
 count      1.000                  1.0                   1.0   1.0000  1.00   
 mean       0.078                 15.0                  37.0   0.9973  3.35   
 std          NaN                  NaN                   NaN      NaN   NaN   
 min        0.078                 15.0                  37.0   0.9973  3.35   
 25%        0.078                 15.0                  37.0   0.9973  3.35   
 50%        0.078                 15.0                  37.0   0.9973  3.35   
 75%        0.078                 15.0                  37.0   0.9973  3.35   
 max        0.078                 15.0                  37.0   0.9973  3.35   
 
        sulphates  alcohol  
 count       1.00      1.0  
 mean        0.86     12.8  
 std          NaN      NaN  
 min         0.86     12.8  
 25%         0.86     12.8  
 50%         0.86     12.8  
 75%         0.86     12.8  
 max         0.86     12.8  ,
 None)</code></pre>
</div>
</div>
<div id="a2ccc03b" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#To numpy arrays for efficient computation.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>wine_df <span class="op">=</span> data_1.copy()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>target_df <span class="op">=</span> data_2.copy()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">#C matrix 11 x 6</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>c_matrix <span class="op">=</span> wine_df.values.T</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">#c vector size 11,  the target wine’s chemical concentrations</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>c_vector <span class="op">=</span> target_df.values.flatten()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Optimization variable, 6 blend weights to determine</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> cp.Variable(c_matrix.shape[<span class="dv">1</span>])</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"C matrix shape: </span><span class="sc">{</span>c_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"c vector shape: </span><span class="sc">{</span>c_vector<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Scalar optimization variable shape: </span><span class="sc">{</span>p<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">#Constraints</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> [p <span class="op">&gt;=</span> <span class="dv">0</span>, cp.<span class="bu">sum</span>(p) <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co">#From the minimization formula</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">#Weighted residual, residual (difference between target and blended concentrations) element-wise division by target values</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>objective <span class="op">=</span> cp.<span class="bu">sum</span>(cp.square((c_vector <span class="op">-</span> c_matrix <span class="op">@</span> p) <span class="op">/</span> c_vector))</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve, Minimize the sum of squared weighted residuals</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> cp.Problem(cp.Minimize(objective), constraints)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>problem.solve()</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="co">#Results</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>optimal_p <span class="op">=</span> p.value</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co">#Corrects tiny negative weights (numerical artifacts)</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>optimal_p <span class="op">=</span> np.maximum(optimal_p, <span class="dv">0</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co">#Resulting blend</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>optimal_blend <span class="op">=</span> c_matrix <span class="op">@</span> optimal_p</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="co">#Print results</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Optimal objective value (minimized sum of squared weighted errors):"</span>, <span class="bu">round</span>(problem.value, <span class="dv">6</span>))</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimal blend weights (p):"</span>, optimal_p.<span class="bu">round</span>(<span class="dv">4</span>))</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">The resulting blend chemical composition:"</span>, optimal_blend.<span class="bu">round</span>(<span class="dv">4</span>))</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Target chemical composition:"</span>, c_vector.<span class="bu">round</span>(<span class="dv">4</span>))</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Sum of weights:"</span>, np.<span class="bu">sum</span>(optimal_p))  <span class="co"># Should be very close to 1</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All weights non-negative:"</span>, np.<span class="bu">all</span>(optimal_p <span class="op">&gt;=</span> <span class="dv">0</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>C matrix shape: (11, 6)
c vector shape: (11,)
Scalar optimization variable shape: (6,)

Optimal objective value (minimized sum of squared weighted errors): 0.409707
Optimal blend weights (p): [0.6145 0.     0.3466 0.     0.     0.039 ]

The resulting blend chemical composition: [10.726   0.4494  0.4362  2.4686  0.0918 14.759  34.6096  0.9979  3.2489
  0.6809 11.0076]
Target chemical composition: [ 7.9     0.35    0.46    3.6     0.078  15.     37.      0.9973  3.35
  0.86   12.8   ]

Sum of weights: 1.0
All weights non-negative: True</code></pre>
</div>
</div>
<div id="34114312" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Target vs. blend</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>chemicals <span class="op">=</span> wine_df.columns</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="bu">len</span>(chemicals))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="fl">0.35</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Absolute values</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>ax1.bar(x <span class="op">-</span> width<span class="op">/</span><span class="dv">2</span>, c_vector, width, label<span class="op">=</span><span class="st">'Target'</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>ax1.bar(x <span class="op">+</span> width<span class="op">/</span><span class="dv">2</span>, optimal_blend, width, label<span class="op">=</span><span class="st">'Optimal Blend'</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Value'</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Target vs. Optimal Blend (Absolute Values)'</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks(x)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>ax1.set_xticklabels(chemicals, rotation<span class="op">=</span><span class="dv">45</span>, ha<span class="op">=</span><span class="st">'right'</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">#Percentage differences</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>perc_diff <span class="op">=</span> (optimal_blend <span class="op">-</span> c_vector) <span class="op">/</span> c_vector <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>ax2.bar(x, perc_diff)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Percentage Difference (%)'</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Percentage Difference from Target'</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>ax2.set_xticks(x)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>ax2.set_xticklabels(chemicals, rotation<span class="op">=</span><span class="dv">45</span>, ha<span class="op">=</span><span class="st">'right'</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>ax2.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="convex_sets_files/figure-html/cell-5-output-1.png" width="950" height="757" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<pre><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
</div>
</section>
<section id="reference" class="level2">
<h2 class="anchored" data-anchor-id="reference">Reference</h2>
<ol type="1">
<li><p>Yang, X.S. (2019). <em>Introduction to algorithms for data mining and machine learning</em>. Academic Press. <a href="https://doi.org/10.1016/c2018-0-02034-4" class="uri">https://doi.org/10.1016/c2018-0-02034-4</a></p></li>
<li><p>Boyd, S., &amp; Vandenberghe, L. (2004). <em>Convex optimization</em>. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511804441" class="uri">https://doi.org/10.1017/CBO9780511804441</a></p></li>
<li><p>What is CVXPY? -. (n.d.). <a href="https://www.cvxpy.org/tutorial/intro/index.html" class="uri">https://www.cvxpy.org/tutorial/intro/index.html</a></p></li>
<li><p>Skinner, D. (2023, February 25). Convex Linear Optimization with CVXPY - Dylan Skinner - Medium. Medium. <a href="https://medium.com/" class="uri">https://medium.com/</a><span class="citation" data-cites="dylanskinner65/convex-linear-optimization-with-cvxpy-5fa1024254ff">@dylanskinner65/convex-linear-optimization-with-cvxpy-5fa1024254ff</span></p></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>